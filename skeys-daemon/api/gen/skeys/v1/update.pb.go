// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.12
// source: skeys/v1/update.proto

package skeysv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// DownloadState represents the state of a download
type DownloadState int32

const (
	DownloadState_DOWNLOAD_STATE_UNSPECIFIED DownloadState = 0
	DownloadState_DOWNLOAD_STATE_STARTING    DownloadState = 1
	DownloadState_DOWNLOAD_STATE_DOWNLOADING DownloadState = 2
	DownloadState_DOWNLOAD_STATE_VERIFYING   DownloadState = 3
	DownloadState_DOWNLOAD_STATE_COMPLETED   DownloadState = 4
	DownloadState_DOWNLOAD_STATE_ERROR       DownloadState = 5
)

// Enum value maps for DownloadState.
var (
	DownloadState_name = map[int32]string{
		0: "DOWNLOAD_STATE_UNSPECIFIED",
		1: "DOWNLOAD_STATE_STARTING",
		2: "DOWNLOAD_STATE_DOWNLOADING",
		3: "DOWNLOAD_STATE_VERIFYING",
		4: "DOWNLOAD_STATE_COMPLETED",
		5: "DOWNLOAD_STATE_ERROR",
	}
	DownloadState_value = map[string]int32{
		"DOWNLOAD_STATE_UNSPECIFIED": 0,
		"DOWNLOAD_STATE_STARTING":    1,
		"DOWNLOAD_STATE_DOWNLOADING": 2,
		"DOWNLOAD_STATE_VERIFYING":   3,
		"DOWNLOAD_STATE_COMPLETED":   4,
		"DOWNLOAD_STATE_ERROR":       5,
	}
)

func (x DownloadState) Enum() *DownloadState {
	p := new(DownloadState)
	*p = x
	return p
}

func (x DownloadState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DownloadState) Descriptor() protoreflect.EnumDescriptor {
	return file_skeys_v1_update_proto_enumTypes[0].Descriptor()
}

func (DownloadState) Type() protoreflect.EnumType {
	return &file_skeys_v1_update_proto_enumTypes[0]
}

func (x DownloadState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DownloadState.Descriptor instead.
func (DownloadState) EnumDescriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{0}
}

// UpdateState represents the overall update system state
type UpdateState int32

const (
	UpdateState_UPDATE_STATE_UNSPECIFIED      UpdateState = 0
	UpdateState_UPDATE_STATE_IDLE             UpdateState = 1
	UpdateState_UPDATE_STATE_CHECKING         UpdateState = 2
	UpdateState_UPDATE_STATE_UPDATE_AVAILABLE UpdateState = 3
	UpdateState_UPDATE_STATE_DOWNLOADING      UpdateState = 4
	UpdateState_UPDATE_STATE_READY_TO_APPLY   UpdateState = 5
	UpdateState_UPDATE_STATE_APPLYING         UpdateState = 6
	UpdateState_UPDATE_STATE_ERROR            UpdateState = 7
)

// Enum value maps for UpdateState.
var (
	UpdateState_name = map[int32]string{
		0: "UPDATE_STATE_UNSPECIFIED",
		1: "UPDATE_STATE_IDLE",
		2: "UPDATE_STATE_CHECKING",
		3: "UPDATE_STATE_UPDATE_AVAILABLE",
		4: "UPDATE_STATE_DOWNLOADING",
		5: "UPDATE_STATE_READY_TO_APPLY",
		6: "UPDATE_STATE_APPLYING",
		7: "UPDATE_STATE_ERROR",
	}
	UpdateState_value = map[string]int32{
		"UPDATE_STATE_UNSPECIFIED":      0,
		"UPDATE_STATE_IDLE":             1,
		"UPDATE_STATE_CHECKING":         2,
		"UPDATE_STATE_UPDATE_AVAILABLE": 3,
		"UPDATE_STATE_DOWNLOADING":      4,
		"UPDATE_STATE_READY_TO_APPLY":   5,
		"UPDATE_STATE_APPLYING":         6,
		"UPDATE_STATE_ERROR":            7,
	}
)

func (x UpdateState) Enum() *UpdateState {
	p := new(UpdateState)
	*p = x
	return p
}

func (x UpdateState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UpdateState) Descriptor() protoreflect.EnumDescriptor {
	return file_skeys_v1_update_proto_enumTypes[1].Descriptor()
}

func (UpdateState) Type() protoreflect.EnumType {
	return &file_skeys_v1_update_proto_enumTypes[1]
}

func (x UpdateState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UpdateState.Descriptor instead.
func (UpdateState) EnumDescriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{1}
}

// UpdateInfo contains information about an available update
type UpdateInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether an update is available
	UpdateAvailable bool `protobuf:"varint,1,opt,name=update_available,json=updateAvailable,proto3" json:"update_available,omitempty"`
	// Current installed version
	CurrentVersion string `protobuf:"bytes,2,opt,name=current_version,json=currentVersion,proto3" json:"current_version,omitempty"`
	// Latest available version
	LatestVersion string `protobuf:"bytes,3,opt,name=latest_version,json=latestVersion,proto3" json:"latest_version,omitempty"`
	// URL to the release page on GitHub
	ReleaseUrl string `protobuf:"bytes,4,opt,name=release_url,json=releaseUrl,proto3" json:"release_url,omitempty"`
	// Release notes/changelog
	ReleaseNotes string `protobuf:"bytes,5,opt,name=release_notes,json=releaseNotes,proto3" json:"release_notes,omitempty"`
	// Size of the download in bytes
	DownloadSize int64 `protobuf:"varint,6,opt,name=download_size,json=downloadSize,proto3" json:"download_size,omitempty"`
	// When the release was published
	PublishedAt *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=published_at,json=publishedAt,proto3" json:"published_at,omitempty"`
	// Whether this is a prerelease
	Prerelease    bool `protobuf:"varint,8,opt,name=prerelease,proto3" json:"prerelease,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateInfo) Reset() {
	*x = UpdateInfo{}
	mi := &file_skeys_v1_update_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateInfo) ProtoMessage() {}

func (x *UpdateInfo) ProtoReflect() protoreflect.Message {
	mi := &file_skeys_v1_update_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateInfo.ProtoReflect.Descriptor instead.
func (*UpdateInfo) Descriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{0}
}

func (x *UpdateInfo) GetUpdateAvailable() bool {
	if x != nil {
		return x.UpdateAvailable
	}
	return false
}

func (x *UpdateInfo) GetCurrentVersion() string {
	if x != nil {
		return x.CurrentVersion
	}
	return ""
}

func (x *UpdateInfo) GetLatestVersion() string {
	if x != nil {
		return x.LatestVersion
	}
	return ""
}

func (x *UpdateInfo) GetReleaseUrl() string {
	if x != nil {
		return x.ReleaseUrl
	}
	return ""
}

func (x *UpdateInfo) GetReleaseNotes() string {
	if x != nil {
		return x.ReleaseNotes
	}
	return ""
}

func (x *UpdateInfo) GetDownloadSize() int64 {
	if x != nil {
		return x.DownloadSize
	}
	return 0
}

func (x *UpdateInfo) GetPublishedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.PublishedAt
	}
	return nil
}

func (x *UpdateInfo) GetPrerelease() bool {
	if x != nil {
		return x.Prerelease
	}
	return false
}

// DownloadUpdateRequest initiates a download
type DownloadUpdateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version to download (empty for latest)
	Version       string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DownloadUpdateRequest) Reset() {
	*x = DownloadUpdateRequest{}
	mi := &file_skeys_v1_update_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadUpdateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadUpdateRequest) ProtoMessage() {}

func (x *DownloadUpdateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_skeys_v1_update_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadUpdateRequest.ProtoReflect.Descriptor instead.
func (*DownloadUpdateRequest) Descriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{1}
}

func (x *DownloadUpdateRequest) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

// DownloadProgress reports download status
type DownloadProgress struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current state of the download
	State DownloadState `protobuf:"varint,1,opt,name=state,proto3,enum=skeys.v1.DownloadState" json:"state,omitempty"`
	// Bytes downloaded so far
	BytesDownloaded int64 `protobuf:"varint,2,opt,name=bytes_downloaded,json=bytesDownloaded,proto3" json:"bytes_downloaded,omitempty"`
	// Total bytes to download
	TotalBytes int64 `protobuf:"varint,3,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// Download speed in bytes per second
	BytesPerSecond int64 `protobuf:"varint,4,opt,name=bytes_per_second,json=bytesPerSecond,proto3" json:"bytes_per_second,omitempty"`
	// Error message if state is ERROR
	Error string `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	// Path to downloaded file when state is COMPLETED
	DownloadedPath string `protobuf:"bytes,6,opt,name=downloaded_path,json=downloadedPath,proto3" json:"downloaded_path,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *DownloadProgress) Reset() {
	*x = DownloadProgress{}
	mi := &file_skeys_v1_update_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DownloadProgress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DownloadProgress) ProtoMessage() {}

func (x *DownloadProgress) ProtoReflect() protoreflect.Message {
	mi := &file_skeys_v1_update_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DownloadProgress.ProtoReflect.Descriptor instead.
func (*DownloadProgress) Descriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{2}
}

func (x *DownloadProgress) GetState() DownloadState {
	if x != nil {
		return x.State
	}
	return DownloadState_DOWNLOAD_STATE_UNSPECIFIED
}

func (x *DownloadProgress) GetBytesDownloaded() int64 {
	if x != nil {
		return x.BytesDownloaded
	}
	return 0
}

func (x *DownloadProgress) GetTotalBytes() int64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *DownloadProgress) GetBytesPerSecond() int64 {
	if x != nil {
		return x.BytesPerSecond
	}
	return 0
}

func (x *DownloadProgress) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *DownloadProgress) GetDownloadedPath() string {
	if x != nil {
		return x.DownloadedPath
	}
	return ""
}

// ApplyUpdateRequest triggers update application
type ApplyUpdateRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Path to the downloaded tarball (from DownloadProgress.downloaded_path)
	TarballPath string `protobuf:"bytes,1,opt,name=tarball_path,json=tarballPath,proto3" json:"tarball_path,omitempty"`
	// Force update even if version check fails
	Force         bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyUpdateRequest) Reset() {
	*x = ApplyUpdateRequest{}
	mi := &file_skeys_v1_update_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyUpdateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyUpdateRequest) ProtoMessage() {}

func (x *ApplyUpdateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_skeys_v1_update_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyUpdateRequest.ProtoReflect.Descriptor instead.
func (*ApplyUpdateRequest) Descriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{3}
}

func (x *ApplyUpdateRequest) GetTarballPath() string {
	if x != nil {
		return x.TarballPath
	}
	return ""
}

func (x *ApplyUpdateRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// ApplyUpdateResponse contains the result of applying an update
type ApplyUpdateResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the update was applied successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Error message if success is false
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Whether a restart is required (daemon will restart itself)
	RestartRequired bool `protobuf:"varint,3,opt,name=restart_required,json=restartRequired,proto3" json:"restart_required,omitempty"`
	// The new version that was installed
	NewVersion    string `protobuf:"bytes,4,opt,name=new_version,json=newVersion,proto3" json:"new_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyUpdateResponse) Reset() {
	*x = ApplyUpdateResponse{}
	mi := &file_skeys_v1_update_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyUpdateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyUpdateResponse) ProtoMessage() {}

func (x *ApplyUpdateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_skeys_v1_update_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyUpdateResponse.ProtoReflect.Descriptor instead.
func (*ApplyUpdateResponse) Descriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{4}
}

func (x *ApplyUpdateResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ApplyUpdateResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ApplyUpdateResponse) GetRestartRequired() bool {
	if x != nil {
		return x.RestartRequired
	}
	return false
}

func (x *ApplyUpdateResponse) GetNewVersion() string {
	if x != nil {
		return x.NewVersion
	}
	return ""
}

// UpdateSettings configures automatic update behavior
type UpdateSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Check for updates automatically on daemon startup
	AutoCheck bool `protobuf:"varint,1,opt,name=auto_check,json=autoCheck,proto3" json:"auto_check,omitempty"`
	// Download updates automatically when available
	AutoDownload bool `protobuf:"varint,2,opt,name=auto_download,json=autoDownload,proto3" json:"auto_download,omitempty"`
	// Apply updates automatically (requires auto_download)
	AutoApply bool `protobuf:"varint,3,opt,name=auto_apply,json=autoApply,proto3" json:"auto_apply,omitempty"`
	// Include prerelease versions
	IncludePrereleases bool `protobuf:"varint,4,opt,name=include_prereleases,json=includePrereleases,proto3" json:"include_prereleases,omitempty"`
	// How often to check for updates (in hours, 0 = only on startup)
	CheckIntervalHours int32 `protobuf:"varint,5,opt,name=check_interval_hours,json=checkIntervalHours,proto3" json:"check_interval_hours,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *UpdateSettings) Reset() {
	*x = UpdateSettings{}
	mi := &file_skeys_v1_update_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateSettings) ProtoMessage() {}

func (x *UpdateSettings) ProtoReflect() protoreflect.Message {
	mi := &file_skeys_v1_update_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateSettings.ProtoReflect.Descriptor instead.
func (*UpdateSettings) Descriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{5}
}

func (x *UpdateSettings) GetAutoCheck() bool {
	if x != nil {
		return x.AutoCheck
	}
	return false
}

func (x *UpdateSettings) GetAutoDownload() bool {
	if x != nil {
		return x.AutoDownload
	}
	return false
}

func (x *UpdateSettings) GetAutoApply() bool {
	if x != nil {
		return x.AutoApply
	}
	return false
}

func (x *UpdateSettings) GetIncludePrereleases() bool {
	if x != nil {
		return x.IncludePrereleases
	}
	return false
}

func (x *UpdateSettings) GetCheckIntervalHours() int32 {
	if x != nil {
		return x.CheckIntervalHours
	}
	return 0
}

// UpdateStatus represents the current state of the update system
type UpdateStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current state
	State UpdateState `protobuf:"varint,1,opt,name=state,proto3,enum=skeys.v1.UpdateState" json:"state,omitempty"`
	// Information about available update (if any)
	AvailableUpdate *UpdateInfo `protobuf:"bytes,2,opt,name=available_update,json=availableUpdate,proto3" json:"available_update,omitempty"`
	// Download progress (if downloading)
	DownloadProgress *DownloadProgress `protobuf:"bytes,3,opt,name=download_progress,json=downloadProgress,proto3" json:"download_progress,omitempty"`
	// Last time updates were checked
	LastCheck *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=last_check,json=lastCheck,proto3" json:"last_check,omitempty"`
	// Error message if state is ERROR
	Error         string `protobuf:"bytes,5,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateStatus) Reset() {
	*x = UpdateStatus{}
	mi := &file_skeys_v1_update_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateStatus) ProtoMessage() {}

func (x *UpdateStatus) ProtoReflect() protoreflect.Message {
	mi := &file_skeys_v1_update_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateStatus.ProtoReflect.Descriptor instead.
func (*UpdateStatus) Descriptor() ([]byte, []int) {
	return file_skeys_v1_update_proto_rawDescGZIP(), []int{6}
}

func (x *UpdateStatus) GetState() UpdateState {
	if x != nil {
		return x.State
	}
	return UpdateState_UPDATE_STATE_UNSPECIFIED
}

func (x *UpdateStatus) GetAvailableUpdate() *UpdateInfo {
	if x != nil {
		return x.AvailableUpdate
	}
	return nil
}

func (x *UpdateStatus) GetDownloadProgress() *DownloadProgress {
	if x != nil {
		return x.DownloadProgress
	}
	return nil
}

func (x *UpdateStatus) GetLastCheck() *timestamppb.Timestamp {
	if x != nil {
		return x.LastCheck
	}
	return nil
}

func (x *UpdateStatus) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

var File_skeys_v1_update_proto protoreflect.FileDescriptor

const file_skeys_v1_update_proto_rawDesc = "" +
	"\n" +
	"\x15skeys/v1/update.proto\x12\bskeys.v1\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xd1\x02\n" +
	"\n" +
	"UpdateInfo\x12)\n" +
	"\x10update_available\x18\x01 \x01(\bR\x0fupdateAvailable\x12'\n" +
	"\x0fcurrent_version\x18\x02 \x01(\tR\x0ecurrentVersion\x12%\n" +
	"\x0elatest_version\x18\x03 \x01(\tR\rlatestVersion\x12\x1f\n" +
	"\vrelease_url\x18\x04 \x01(\tR\n" +
	"releaseUrl\x12#\n" +
	"\rrelease_notes\x18\x05 \x01(\tR\freleaseNotes\x12#\n" +
	"\rdownload_size\x18\x06 \x01(\x03R\fdownloadSize\x12=\n" +
	"\fpublished_at\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\vpublishedAt\x12\x1e\n" +
	"\n" +
	"prerelease\x18\b \x01(\bR\n" +
	"prerelease\"1\n" +
	"\x15DownloadUpdateRequest\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\"\xf6\x01\n" +
	"\x10DownloadProgress\x12-\n" +
	"\x05state\x18\x01 \x01(\x0e2\x17.skeys.v1.DownloadStateR\x05state\x12)\n" +
	"\x10bytes_downloaded\x18\x02 \x01(\x03R\x0fbytesDownloaded\x12\x1f\n" +
	"\vtotal_bytes\x18\x03 \x01(\x03R\n" +
	"totalBytes\x12(\n" +
	"\x10bytes_per_second\x18\x04 \x01(\x03R\x0ebytesPerSecond\x12\x14\n" +
	"\x05error\x18\x05 \x01(\tR\x05error\x12'\n" +
	"\x0fdownloaded_path\x18\x06 \x01(\tR\x0edownloadedPath\"M\n" +
	"\x12ApplyUpdateRequest\x12!\n" +
	"\ftarball_path\x18\x01 \x01(\tR\vtarballPath\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"\x91\x01\n" +
	"\x13ApplyUpdateResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12)\n" +
	"\x10restart_required\x18\x03 \x01(\bR\x0frestartRequired\x12\x1f\n" +
	"\vnew_version\x18\x04 \x01(\tR\n" +
	"newVersion\"\xd6\x01\n" +
	"\x0eUpdateSettings\x12\x1d\n" +
	"\n" +
	"auto_check\x18\x01 \x01(\bR\tautoCheck\x12#\n" +
	"\rauto_download\x18\x02 \x01(\bR\fautoDownload\x12\x1d\n" +
	"\n" +
	"auto_apply\x18\x03 \x01(\bR\tautoApply\x12/\n" +
	"\x13include_prereleases\x18\x04 \x01(\bR\x12includePrereleases\x120\n" +
	"\x14check_interval_hours\x18\x05 \x01(\x05R\x12checkIntervalHours\"\x96\x02\n" +
	"\fUpdateStatus\x12+\n" +
	"\x05state\x18\x01 \x01(\x0e2\x15.skeys.v1.UpdateStateR\x05state\x12?\n" +
	"\x10available_update\x18\x02 \x01(\v2\x14.skeys.v1.UpdateInfoR\x0favailableUpdate\x12G\n" +
	"\x11download_progress\x18\x03 \x01(\v2\x1a.skeys.v1.DownloadProgressR\x10downloadProgress\x129\n" +
	"\n" +
	"last_check\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tlastCheck\x12\x14\n" +
	"\x05error\x18\x05 \x01(\tR\x05error*\xc2\x01\n" +
	"\rDownloadState\x12\x1e\n" +
	"\x1aDOWNLOAD_STATE_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17DOWNLOAD_STATE_STARTING\x10\x01\x12\x1e\n" +
	"\x1aDOWNLOAD_STATE_DOWNLOADING\x10\x02\x12\x1c\n" +
	"\x18DOWNLOAD_STATE_VERIFYING\x10\x03\x12\x1c\n" +
	"\x18DOWNLOAD_STATE_COMPLETED\x10\x04\x12\x18\n" +
	"\x14DOWNLOAD_STATE_ERROR\x10\x05*\xf2\x01\n" +
	"\vUpdateState\x12\x1c\n" +
	"\x18UPDATE_STATE_UNSPECIFIED\x10\x00\x12\x15\n" +
	"\x11UPDATE_STATE_IDLE\x10\x01\x12\x19\n" +
	"\x15UPDATE_STATE_CHECKING\x10\x02\x12!\n" +
	"\x1dUPDATE_STATE_UPDATE_AVAILABLE\x10\x03\x12\x1c\n" +
	"\x18UPDATE_STATE_DOWNLOADING\x10\x04\x12\x1f\n" +
	"\x1bUPDATE_STATE_READY_TO_APPLY\x10\x05\x12\x19\n" +
	"\x15UPDATE_STATE_APPLYING\x10\x06\x12\x16\n" +
	"\x12UPDATE_STATE_ERROR\x10\a2\xc0\x03\n" +
	"\rUpdateService\x12?\n" +
	"\x0fCheckForUpdates\x12\x16.google.protobuf.Empty\x1a\x14.skeys.v1.UpdateInfo\x12O\n" +
	"\x0eDownloadUpdate\x12\x1f.skeys.v1.DownloadUpdateRequest\x1a\x1a.skeys.v1.DownloadProgress0\x01\x12J\n" +
	"\vApplyUpdate\x12\x1c.skeys.v1.ApplyUpdateRequest\x1a\x1d.skeys.v1.ApplyUpdateResponse\x12E\n" +
	"\x11GetUpdateSettings\x12\x16.google.protobuf.Empty\x1a\x18.skeys.v1.UpdateSettings\x12G\n" +
	"\x11SetUpdateSettings\x12\x18.skeys.v1.UpdateSettings\x1a\x18.skeys.v1.UpdateSettings\x12A\n" +
	"\x0fGetUpdateStatus\x12\x16.google.protobuf.Empty\x1a\x16.skeys.v1.UpdateStatusB7Z5github.com/johnnelson/skeys-daemon/api/gen/v1;skeysv1b\x06proto3"

var (
	file_skeys_v1_update_proto_rawDescOnce sync.Once
	file_skeys_v1_update_proto_rawDescData []byte
)

func file_skeys_v1_update_proto_rawDescGZIP() []byte {
	file_skeys_v1_update_proto_rawDescOnce.Do(func() {
		file_skeys_v1_update_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_skeys_v1_update_proto_rawDesc), len(file_skeys_v1_update_proto_rawDesc)))
	})
	return file_skeys_v1_update_proto_rawDescData
}

var file_skeys_v1_update_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_skeys_v1_update_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_skeys_v1_update_proto_goTypes = []any{
	(DownloadState)(0),            // 0: skeys.v1.DownloadState
	(UpdateState)(0),              // 1: skeys.v1.UpdateState
	(*UpdateInfo)(nil),            // 2: skeys.v1.UpdateInfo
	(*DownloadUpdateRequest)(nil), // 3: skeys.v1.DownloadUpdateRequest
	(*DownloadProgress)(nil),      // 4: skeys.v1.DownloadProgress
	(*ApplyUpdateRequest)(nil),    // 5: skeys.v1.ApplyUpdateRequest
	(*ApplyUpdateResponse)(nil),   // 6: skeys.v1.ApplyUpdateResponse
	(*UpdateSettings)(nil),        // 7: skeys.v1.UpdateSettings
	(*UpdateStatus)(nil),          // 8: skeys.v1.UpdateStatus
	(*timestamppb.Timestamp)(nil), // 9: google.protobuf.Timestamp
	(*emptypb.Empty)(nil),         // 10: google.protobuf.Empty
}
var file_skeys_v1_update_proto_depIdxs = []int32{
	9,  // 0: skeys.v1.UpdateInfo.published_at:type_name -> google.protobuf.Timestamp
	0,  // 1: skeys.v1.DownloadProgress.state:type_name -> skeys.v1.DownloadState
	1,  // 2: skeys.v1.UpdateStatus.state:type_name -> skeys.v1.UpdateState
	2,  // 3: skeys.v1.UpdateStatus.available_update:type_name -> skeys.v1.UpdateInfo
	4,  // 4: skeys.v1.UpdateStatus.download_progress:type_name -> skeys.v1.DownloadProgress
	9,  // 5: skeys.v1.UpdateStatus.last_check:type_name -> google.protobuf.Timestamp
	10, // 6: skeys.v1.UpdateService.CheckForUpdates:input_type -> google.protobuf.Empty
	3,  // 7: skeys.v1.UpdateService.DownloadUpdate:input_type -> skeys.v1.DownloadUpdateRequest
	5,  // 8: skeys.v1.UpdateService.ApplyUpdate:input_type -> skeys.v1.ApplyUpdateRequest
	10, // 9: skeys.v1.UpdateService.GetUpdateSettings:input_type -> google.protobuf.Empty
	7,  // 10: skeys.v1.UpdateService.SetUpdateSettings:input_type -> skeys.v1.UpdateSettings
	10, // 11: skeys.v1.UpdateService.GetUpdateStatus:input_type -> google.protobuf.Empty
	2,  // 12: skeys.v1.UpdateService.CheckForUpdates:output_type -> skeys.v1.UpdateInfo
	4,  // 13: skeys.v1.UpdateService.DownloadUpdate:output_type -> skeys.v1.DownloadProgress
	6,  // 14: skeys.v1.UpdateService.ApplyUpdate:output_type -> skeys.v1.ApplyUpdateResponse
	7,  // 15: skeys.v1.UpdateService.GetUpdateSettings:output_type -> skeys.v1.UpdateSettings
	7,  // 16: skeys.v1.UpdateService.SetUpdateSettings:output_type -> skeys.v1.UpdateSettings
	8,  // 17: skeys.v1.UpdateService.GetUpdateStatus:output_type -> skeys.v1.UpdateStatus
	12, // [12:18] is the sub-list for method output_type
	6,  // [6:12] is the sub-list for method input_type
	6,  // [6:6] is the sub-list for extension type_name
	6,  // [6:6] is the sub-list for extension extendee
	0,  // [0:6] is the sub-list for field type_name
}

func init() { file_skeys_v1_update_proto_init() }
func file_skeys_v1_update_proto_init() {
	if File_skeys_v1_update_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_skeys_v1_update_proto_rawDesc), len(file_skeys_v1_update_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_skeys_v1_update_proto_goTypes,
		DependencyIndexes: file_skeys_v1_update_proto_depIdxs,
		EnumInfos:         file_skeys_v1_update_proto_enumTypes,
		MessageInfos:      file_skeys_v1_update_proto_msgTypes,
	}.Build()
	File_skeys_v1_update_proto = out.File
	file_skeys_v1_update_proto_goTypes = nil
	file_skeys_v1_update_proto_depIdxs = nil
}
